In this section the Crosscutting Framework Integrated Reuse Environment (CrossFIRE) is presented. Figure~\ref{fig:proline} depicts a screenshot of CrossFIRE.

\begin{figure}[!h]
\centering
  % Requires \usepackage{graphicx}%left,bottom, right and top
 \includegraphics[%scale=0.063, clip=true, trim=32.23cm 18cm 5.45cm 13.853cm
 width=1\textwidth
 ]{Figuras/PROLINERM}
\caption{Screenshot of CrossFIRE}
\label{fig:proline}
\end{figure}


All artifacts of the CF/CFF must be developed before one uses the CrossFIRE. Thus, it is worth highlighting that CrossFIRE only supports the Application Engineering (AE) phase. Having this in mind, the domain engineer has to use a traditional approach in order to create the artifacts in the Domain Engineering (DE) phase. In the DE phase, three artifacts must be created: (\textit{i}) source code of the whole CF, (\textit{ii}) the RRM and (\textit{iii}) the feature models of the CFF. These feature models have to be devised using the FeatureIDE\footnote{\url{http://wwwiti.cs.uni-magdeburg.de/iti_db/research/featureide/}}, which is a tool that provides a graphical way to assemble feature models. Afterwards, the engineer can use the CrossFIRE in order to uploaded these artifacts into a repository, as is shown in Figure~\ref{fig:proline}(A).    


In the AE phase, an application engineer can browse the repository in order to check whether there are CFs that can be reused in order to implement concerns of the planned application. In order to assist this activity, CrossFIRE provides a visualization, which depicts all CFs/CFFs that have been uploaded by the domain engineers.
Figure~\ref{fig:proline}(B) shows the visualization of all CFs/CFFs available.
As can be seen, there are six different CFFs - persistence, security, distribution, concurrency, logging and 	Business, respectively. 
In addition, CrossFIRE also shows descriptions for each of the selected CFFs by clicking on the button ``Description''. 
%Using this description the engineer can choose the CFFs. 
Nevertheless, if this description is not enough to help the engineer takes a decision on reusing the CF/CFF, CrossFIRE supplies a way to visualize the feature model related to selected CF/CFF by clicking on the button ``View'', Figure~\ref{fig:proline}(C). 
As is shown in Figure~\ref{fig:proline}(B), the ``persistence'' CF is highlighted to indicate that it has been chosen. 
Next, the ``Download'' button has to be clicked to transfer the feature model belonging to the CF chosen from the remote repository to the computer of the application engineer.

Furthermore, to reuse the CFF, its features must be chosen by the engineer aiming at specifying explicitly which features will be reused in the base application. %This is important because CFFs may have a great deal of features that probably will not be used in the application base. 
To assist this activity, CrossFIRE uses the ``configuration file'' of FeatureIDE. By using this ``configuration file'', features can be chosen by the application engineer. The graphical notation of the ``configuration file'' is shown in Figure~\ref{fig:proline}(D), which represents all features of the ``persistence'' CF. Moreover, FeatureIDE validates if the selected features match a valid combination for the instantiation of a member of the CFF. As shown in Figure~\ref{fig:proline}(D), once the application engineer has chosen the features (represented by ``+''), the resulting variant and constraints are generated automatically (represented by ``-''). 


The application engineer should provide  the selected features by using the ``configuration file'' to repository server, which will carry out an algorithm. This algorithm aims to extract two artifacts. The first extracted artifact only contains code related to the selected features. The second extracted artifact is a RM derived from a RRM, by removing unrelated requirements. The RM is used to support the reuse process of a CF. After that, these artifacts are sent to the application engineer's computer. %As can be seen in Figure~\ref{fig:proline}(3) the repository sent only the packages related to the features selected and specified through the ``configuration file'' i.e., the features Persistence, Connection and MySQL.


%he first artifact is the source code of the selected features

To reuse a member of the CFF or any other CF persisted in the repository, the application engineer may use the RM. It is graphically represented as a form which contains fields that should be filled with information regarding the base application. By completing this form, the code needed to couple the CF to the base application can be generated. It is possible to see our model editor in Figure~\ref{fig:rm}. 
The ``Palette'' on the right of the figure contains the elements of the RMs. They are:
 ``Group'': an element to group any element visible in the models;
 ``Pointcut'': represents join-points of the base application;
 ``TypeExtension'': represents types found in the base application;
 ``Value'': represents any numeric or textual values that must be informed while reusing the CF;
 ``Option'': defines a selectable variability of the framework and
 ``OptionGroup'': group selectable variabilities of the framework.

Each box contains a name and a description for the required information. The last line should be filled to provide the information regarding the base application. Note that the last line is only used  in RMs. For example, to be able to instantiate a persistence CF, the application engineer must specify methods from base application that should be executed after a database connection is opened and before it is closed.Then, the box ``Connection Opening'' in  Figure~\ref{fig:rm} represents  names of methods that need an open database connection.It is also needed to specify methods that represent data base transactions, and the variabilities must be chosen, e.g., the driver which should be used to connect to the database system. After filling the fields of the RM, a model transformation generates the code needed to couple the CF, and then, the reuse process is complete.
 Our tool also provides validation of the information filled into RM models.
 At the moment this paper was written, only AspectJ CFs are supported.

\begin{figure}[!h]
\centering
  % Requires \usepackage{graphicx}%left,bottom, right and top
 \includegraphics[%scale=0.063, clip=true, trim=32.23cm 18cm 5.45cm 13.853cm
 width=1\textwidth
 ]{Figuras/reuse_form}
\caption{Reuse Model Editor}
\label{fig:rm}
\end{figure}


%The ``Persistent Objects'' is a type extension definition, then, it might represent either a class or an interface that should be extended or implemented by a base class or interface. In this case, the application engineer must supply names of classes (or their super-types), which represent objects that should be persisted on the database.
    
%The following elements represent framework variabilities that should be chosen or defined by the application developer. ``Value definitions'' represent values that should be informed to the framework and ``Options'' represent predefined options that should be chosen by the application engineer. The application engineer may define the selected option or options by setting true or false for each option.

%``Connection Pools Number'' is an integer value which is used to inform the framework how many database connections should be kept open by the connection pool. 
%``Dirty Objects Controller'' is a boolean value which is used to define if the dirty objects controller should be active. This is used to update the database records automatically as soon as any attribute belonging to a persistent object is changed by a set method. ``Database Username'' and ``Database Password'' are string values that are used to define the username and password needed to log into the database system. ``Database Connection String'' is a string value which should be used to specify the database connection details, i.e., the database system address, port and database name.

%``Database connection driver'' is an option group, representing possible connections that may be chosen by the application engineer, either native driver connection or via ODBC. ``Database System'' is an option group which represents the implementation of the database management system. The application engineer should select the database system which the application should connect to. ``Obliviousness level'' is an option group that represents the level of obliviousness found on the base application classes. ``Total obliviousness'' means that the base application does not need to call any method in order to save the persistent objects, however, when the ``Partial obliviousness'' is set, the base application must call an method inherited by persistent objects.

% There are three referenced ``Persistent Objects''; their classes will receive methods and crosscutting behavior in order to implement the persistence concern.

%After completing the RM, it is possible to execute a code generator, which is a model to code transformation tool capable of generating reuse code in AspectJ. This reuse code is not show due space limitation.