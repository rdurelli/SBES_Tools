%Since the advent of aspect-oriented programming (AOP), much of researchers have employed AOP abstractions and concepts in the development of product lines~\cite{Clements} and frameworks~\cite{Fayad:1997:OAF:262793.262798}. Some authors employ aspects to modularize features of product lines, others adopt them in the modularization of framework architectures, while others aims to improve the reuse of crosscutting concerns.

Crosscutting Framework (CF) is a term we have proposed in a previous work to represent an abstract aspect-oriented design of a crosscutting concern (CC), e.g., persistence, security and distribution~\citep{camanais}. %The aim is to make the reuse of these CCs a more systematic and controlled task. 
The reuse process of CFs has two steps; instantiation and composition. The instantiation involves variability selection and hook implementation, while the composition involves providing composition rules to couple the chosen variabilities to a base code. 
%
Another important term in this paper is Crosscutting Framework Families (CFFs)~\cite{valterCFF}. A CFF is a set of features in which their composition results in a CF, that is, a member of this family is a CF. %The main ideia behind CFF is to allow application engineers to be able to choose only the features of interest. 
The difference between CF and CFF is that, in the later, there are several features which can be composed before starting the reuse process, while in the former there is no feature selection - the framework is ready to be used.



%Crosscutting Framework Families (CFF) is a set of features, which their composition results in a CF, e.g., the member of this family is a CF. The main idea behind CFF is to allow application engineers to be able to choose only the features of interest. %Nevertheless, as any common framework, when crosscutting frameworks are used for developing an application, usually all of their features and variabilities remain in the final architecture, even if only a subset of them was needed. This leads to a poor design with several pieces of death code, making the maintenance activities difficult. 

Most of the CFs found in literature apply white-box reuse strategies, % in their instantiation process, 
 relying on writing source code to reuse the framework~\citep{Kulesza06improvingextensibility,
camanais,bynens,sakenou,cunha}. 
White-box strategy makes application engineers to worry about low level implementation details during the reuse process, leading to the following problems: (\textit{i}) the need to know coding details regarding the programming paradigm employed in the framework, making the learning curve steeper; (\textit{ii}) coding mistakes are more likely to happen when the reuse code is created manually; (\textit{iii}) several lines of code must be written for the definitions of small number of hooks, impacting development productivity and (\textit{iv}) reuse process can only be started during implementation phase, as there is no source code in earlier phases.

 To overcome the described problems, we put forward an infrastructure which supports (\textit{i}) the storage of CFFs/CFs, (\textit{ii}) the feature selection and (\textit{iii}) the model-based reuse process of CFs. In our infrastructure, domain engineers can make their CF/CFF available and application engineers can use one or more CFs in their application development in a model-based fashion.


There are two models that support the reuse process:  
  Reuse Requirements Model (RRM) and Reuse Model (RM). The RRM documents all the information needed to perform the composition of a CF. %Based on the RRM, the application engineer can then select just the desired features, building a more specific model, referred as RM. 
 The RM is instantiated along with the framework member, thus, it only contains the composition information related to the selected features.
 This model is also employed to conclude the reuse process in our model-driven approach by filling the fields of this model, which is also used for code generation.
%The main contributions of this paper are: (\textit{i}) showing an infrastructure which implements complete cycle of reuse of the CFs and (\textit{ii}) presenting a model-based approach for CFs. 
%In this paper we are using yet another related term, which is ``Crosscutting Framework Families'' (CFF)~\cite{valterCFF}. A CFF is a set of features which their composition results in a CF, that is, the member (product) of this family is a CF. The main idea behind CFFs is to allow domain engineers to be able to choose only the features of interest. Nevertheless, as any common framework, when crosscutting frameworks are used for developing an application, usually all of their features and variabilities remain in the final architecture, even if only a subset of them was needed. This leads to a poor design with several pieces of death code, making the maintenance activities difficult. To overcome such difficult in this paper is put forward a plug-in which implements complete cycle of reuse of the Crosscutting Frameworks. By using this plug-in the engineer can choose the features that the application really requires through a feature model. Next, the plug-in provides a way to download only the necessaries pieces of code that the application requires, avoiding death code.	
%The rest of the paper is structured as follows. Section~\ref{sec:motivation} presents the motivation. Section~\ref{sec:proline} describes the CrossFIRE. The tool architecture, notation and components are detailed in Section~\ref{sec:architecture}. In Section~\ref{sec:related} some related tools are presented. Finally, Section~\ref{sec:conclusion} presents the final considerations and pointers for future work.
The motivation is the following: (\textit{i}) there is neither a repository, in which the CFs/CFFs can be stored by domain engineer in order to share it, nor an infrastructure where the CFs can be reused as easy as possible in order to disseminate them; (\textit{ii}) most of the CFs found apply white-box reuse strategies - thus it is important provides a way to assist the instantiation of these CFs using models. This paper is organized as followed: Section~\ref{sec:proline} provides information related to CrossFIRE - Section~\ref{sec:architecture} the architecture of CrossFIRE is depicted - in Section~\ref{sec:related} there are related works and in Section~\ref{sec:conclusion} we conclude the paper with some remarks and future directions.

%Aspect-Oriented Programming (AOP) is a paradigm created to   improve code modularization. AOP languages
%provide constructions to allow modularization of crosscutting concerns, which are concerns that may affect several parts of code and cannot be modularized correctly with many other paradigms, e.g. Object-Oriented~\cite{Kiczales97aspect-orientedprogramming}.

%Crosscutting Frameworks (CF) encapsulate the generic behavior of a single crosscutting concern. There are CF developed for persistence, security, distribution and other concerns. Their main objective is to make the reuse of such concerns easier during the development of an application without the need to use explicit function calls from the base code. 

%Crosscutting Frameworks encapsulate the generic behavior of a single crosscutting concern \cite{camanais}. There are crosscutting frameworks developed for persistence \cite{soares,camanais}, security \cite{shah}, cryptography \cite{huang}, distribution \cite{soares} and other concerns \cite{Mortensen_creatingpluggable}.
 % Their main objective is to make to reuse of such concerns easier during the development of an application without the need to use explicit function calls from the base code.